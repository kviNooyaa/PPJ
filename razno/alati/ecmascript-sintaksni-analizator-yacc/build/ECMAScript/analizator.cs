//
//  This CSharp output file generated by Gardens Point LEX
//  Version:  0.6.2.196 (2007-11-13)
//  Machine:  URSUS-PC
//  DateTime: 22.12.2008 23:45:45
//  UserName: Ursus
//  GPLEX input file <analizator.lex>
//  GPLEX frame file <gplexx.frame>
//
//  Option settings: verbose, noparser, minimize, compressnext
//

#define BACKUP
#define STANDALONE
//
// gplexx.frame
// Version 0.6.2 of 13-November-2007
// Derived from gplex.frame version of 2-September-2006. 
// Left and Right Anchored state support.
// Start condition stack. Two generic params.
// Using fixed length context handling for right anchors
//
using System;
using System.IO;
using System.Collections.Generic;
#if !STANDALONE
using gppg;
#endif

using System.Linq;
using System.Collections;
using System.Text;

namespace ListCollection
{   
    /// <summary>
    /// Summary Canonical example of GPLEX automaton
    /// </summary>
    
#if STANDALONE
    //
    // These are the dummy declarations for stand-alone GPLEX applications
    // normally these declarations would come from the parser.
    // If you declare /noparser, or %option noparser then you get this.
    //


    public abstract class ScanBase
    {
        public abstract int yylex();
#if BABEL
        protected abstract int CurrentSc { get; set; }
        // EolState is the 32-bit of state data persisted at 
        // the end of each line for Visual Studio colorization.  
        // The default is to return CurrentSc.  You must override
        // this if you want more complicated behavior.
        public virtual int EolState { 
            get { return CurrentSc; }
            set { CurrentSc = value; } 
        }
    }
    
    public interface IColorScan
    {
        void SetSource(string source, int offset);
        int GetNext(ref int state, out int start, out int end);
#endif // BABEL
    }

#endif // STANDALONE

    public abstract class ScanBuff
    {
        public const int EOF = -1;
        public abstract int Pos { get; set; }
        public abstract int Read();
        public abstract int Peek();
        public abstract int ReadPos { get; }
        public abstract string GetString(int b, int e);
    }
    
    // If the compiler can't find ScanBase maybe you need to run
    // GPPG with the /gplex option, or GPLEX with /noparser
#if BABEL
    public sealed partial class Scanner : ScanBase, IColorScan
    {
        public ScanBuff buffer;
        int currentScOrd;  // start condition ordinal
        
        protected override int CurrentSc 
        {
             // The current start state is a property
             // to try to avoid the user error of setting
             // scState but forgetting to update the FSA
             // start state "currentStart"
             //
             get { return currentScOrd; }  // i.e. return YY_START;
             set { currentScOrd = value;   // i.e. BEGIN(value);
                   currentStart = startState[value]; }
        }
#else  // BABEL
    public sealed partial class Scanner : ScanBase
    {
        public ScanBuff buffer;
        int currentScOrd;  // start condition ordinal
#endif // BABEL
        
        private static int GetMaxParseToken() {
            System.Reflection.FieldInfo f = typeof(Tokens).GetField("maxParseToken");
            return (f == null ? int.MaxValue : (int)f.GetValue(null));
        }
        
        static int parserMax = GetMaxParseToken();
        
        enum Result {accept, noMatch, contextFound};

        const int maxAccept = 101;
        const int initial = 102;
        const int eofNum = 0;
        const int goStart = -1;
        const int INITIAL = 0;
        const int unarni = 1;
        const int unarni_zagrada = 2;

static int lineTot = 1;

    static int Adr_IDN = 0;
    static int Adr_KONS = 0;
    static int pointer = 0;
    static ULAZ ulazno_Polje = new ULAZ();
    static Liste Lists = new Liste();

    public TUZ Tabl_unif_znak;
   


public class C_KROS
{

    private int pokazivac;
    private string naziv;

    // Constructor
    public C_KROS(int pokazivac, string naziv)
    {
        this.pokazivac = pokazivac;
        this.naziv = naziv;
    }

    private bool Exists(string ime)
    {
        if (this.naziv == ime)
            return true;
        else
            return false;
    }
    public int Pointer(string ime)
    {
        if (this.Exists(ime))
        {
            return this.pokazivac;
        }
        else
        {
            return 0;
        }
    }
    public void PrintToConsole()
    {
        Glavni.mojaForma.KROSdataGrid.Rows.Add(this.pokazivac, this.naziv);
    }


    public string Give_Back_naziv()
    {
        return this.naziv;
    }
    public int Give_Back_pokazivac()
    {
        return this.pokazivac;
    }
}

public class C_KONST : IComparable<C_KONST>
{

    private int pokazivac;
    private string vrijednost;
    private string tip;

    // Constructor
    public C_KONST(int pokazivac, string vrijednost, string tip)
    {
        this.pokazivac = pokazivac;
        this.vrijednost = vrijednost;
        this.tip = tip;
    }
    private bool Exists(string ime)
    {
        if (this.vrijednost == ime)
            return true;
        else
            return false;
    }
    public int Pointer(string ime)
    {
        if (this.Exists(ime))
        {
            return this.pokazivac;
        }
        else
        {
            return 0;
        }
    }
    public void PrintToConsole()
    {
        Glavni.mojaForma.KonstDataGrid.Rows.Add(this.pokazivac.ToString(), this.vrijednost, this.tip);
    }
    public int CompareTo(C_KONST rhs)
    {
        return this.vrijednost.CompareTo(rhs.vrijednost);
    }
    public string Give_Back_vrijednost()
    {
        return this.vrijednost;
    }
    public string Give_Back_tip()
    {
        return this.tip;
    }
    public int Give_Back_pokazivac()
    {
        return this.pokazivac;
    }

    public void Set_tip(string novi_tip)
    {
        this.tip = novi_tip;
    }

}

public class C_IDENT : IComparable<C_IDENT>
{

    private int pokazivac;
    private string naziv;
    private string tip;

    // Constructor
    public C_IDENT(int pokazivac, string naziv, string tip)
    {
        this.pokazivac = pokazivac;
        this.naziv = naziv;
        this.tip = tip;
    }

    private bool Exists(string ime)
    {
        if (this.naziv == ime)
            return true;
        else
            return false;
    }
    public int Pointer(string ime)
    {
        if (this.Exists(ime))
        {
            return this.pokazivac;
        }
        else
        {
            return 0;
        }
    }
    public int CompareTo(C_IDENT rhs)
    {
        return this.naziv.CompareTo(rhs.naziv);
    }
    public void PrintToConsole()
    {
        Glavni.mojaForma.IdentDataGrid.Rows.Add(this.pokazivac.ToString(), this.naziv, this.tip);
    }
    public int Give_Back_pokazivac()
    {
        return this.pokazivac;
    }

    public string Give_Back_naziv()
    {
        return this.naziv;
    }
    public string Give_Back_tip()
    {
        return this.tip;
    }
    public void Set_tip(string novi_tip)
    {
        this.tip = novi_tip;
    }
}

public class C_UNIFORM_Z
{
    private string klasa;
    private int pokazivac;
    private int redak;

    // Constructor
    public C_UNIFORM_Z(string klasa, int pokazivac, int redak)
    {
        this.klasa = klasa;
        this.pokazivac = pokazivac;
        this.redak = redak;
    }
    public void PrintToConsole()
    {
        Glavni.mojaForma.UZdataGrid.Rows.Add(this.klasa, this.pokazivac.ToString(), this.redak.ToString());
    }
    public string Give_Back_Klasa()
    {
        return this.klasa;
    }
    public int Give_Back_Pokazivac()
    {
        return this.pokazivac;
    }

    public int Give_Back_Redak()
    {
        return this.redak;
    }
}

public class Liste
{
    public List<C_KROS> KROS_List;
    public List<C_IDENT> IDENT_List;
    public List<C_KONST> KONST_List;

    public Liste()
    {
        this.KROS_List = new List<C_KROS>();
        this.IDENT_List = new List<C_IDENT>();
        this.KONST_List = new List<C_KONST>();
    }

    
    public void AddKrosList()
    {

                ArrayList KrosZnak = new ArrayList();
                KrosZnak.Add(";");
				KrosZnak.Add(",");
				KrosZnak.Add(".");
				KrosZnak.Add(":");
                KrosZnak.Add("{");
                KrosZnak.Add("}");
                KrosZnak.Add("(");
                KrosZnak.Add(")");
                KrosZnak.Add("=");
                KrosZnak.Add("AND");
                KrosZnak.Add("OR");				
                KrosZnak.Add("EQ");
				KrosZnak.Add("NEQ");
				KrosZnak.Add("LE");
				KrosZnak.Add("GE");
				KrosZnak.Add("!");
                KrosZnak.Add("<");
                KrosZnak.Add(">");
                KrosZnak.Add("[");
                KrosZnak.Add("]");
                KrosZnak.Add("+");
                KrosZnak.Add("-");
                KrosZnak.Add("*");
                KrosZnak.Add("/");
				KrosZnak.Add("IF");
				KrosZnak.Add("ELSE");
                KrosZnak.Add("WHILE");
                KrosZnak.Add("DO");
				KrosZnak.Add("FOR");
                KrosZnak.Add("RETURN");
				KrosZnak.Add("CONTINUE");
				KrosZnak.Add("BREAK");
				KrosZnak.Add("DEFAULT");
				KrosZnak.Add("SWITCH");
				KrosZnak.Add("CASE");
				KrosZnak.Add("VAR");
				KrosZnak.Add("NEW");
				KrosZnak.Add("THIS");
				KrosZnak.Add("FUNCTION");


                for (int i = 1; i <= KrosZnak.Count; i++)
                {
                    KROS_List.Add(new C_KROS(i, KrosZnak[i - 1].ToString()));
                }

    }

    public int Find_Indx(string ime, int lista)
    {

        int pok = 0;
        switch (lista)
        {
            case 1: //KROS tablica 
                {
                    for (int i = 0; i < KROS_List.Count; i++)
                    {
                        if ((pok = KROS_List[i].Pointer(ime)) != 0)
                        {
                            return pok;
                        }
                    }
                    return 0;
                }
            case 2: //Tablica identifikatora
                {
                    for (int i = 0; i < IDENT_List.Count; i++)
                    {
                        if ((pok = IDENT_List[i].Pointer(ime)) != 0)
                        {
                            return pok;
                        }
                    }
                    return 0;

                }
            case 3: //Tablica konstanti
                {
                    for (int i = 0; i < KONST_List.Count; i++)
                    {
                        if ((pok = KONST_List[i].Pointer(ime)) != 0)
                        {
                            return pok;
                        }
                    }
                    return 0;

                }
            default:
                return 0;
        };
    }
    public void Sort()
    {
        KONST_List.Sort();
        IDENT_List.Sort();
    }
    public void Ispsi_KROS()
            {
                for (int i = 0; i < KROS_List.Count; i++)
                {
                    KROS_List[i].PrintToConsole();
                }
            }
   public void Ispsi_IDEN()
            {
                for (int i = 0; i < IDENT_List.Count; i++)
                {
                    IDENT_List[i].PrintToConsole();
                }
            }
   public void Ispsi_KONS()
            {
                for (int i = 0; i < KONST_List.Count; i++)
                {
                    KONST_List[i].PrintToConsole();
                }
            }
   public int Binary_Search_for_Index(string lista_switch, int vrijednost)
   {


       int donja_granica = 0;
       int gornja_granica = 0;
       int srednji = 0;
       switch (lista_switch)
       {
           case "KROS": //KROS tablica 
               {
                   gornja_granica = KROS_List.Count;
                   while (true)
                   {
                       srednji = (int)((donja_granica + gornja_granica) / 2);
                       if (KROS_List[srednji].Give_Back_pokazivac() == vrijednost)
                       {
                           return srednji;
                       }
                       if (donja_granica >= gornja_granica)
                       {
                           return 0;
                       }
                       if (KROS_List[srednji].Give_Back_pokazivac() < vrijednost)
                       {
                           donja_granica = srednji + 1;
                       }
                       if (KROS_List[srednji].Give_Back_pokazivac() > vrijednost)
                       {
                           gornja_granica = srednji - 1;
                       }

                   }
               }
           case "IDENT": //Tablica identifikatora
               {
                   gornja_granica = IDENT_List.Count;
                   while (true)
                   {
                       srednji = (int)((donja_granica + gornja_granica) / 2);
                       if (IDENT_List[srednji].Give_Back_pokazivac() == vrijednost)
                       {
                           return srednji;
                       }
                       if (donja_granica >= gornja_granica)
                       {
                           return 0;
                       }
                       if (IDENT_List[srednji].Give_Back_pokazivac() < vrijednost)
                       {
                           donja_granica = srednji + 1;
                       }
                       if (IDENT_List[srednji].Give_Back_pokazivac() > vrijednost)
                       {
                           gornja_granica = srednji - 1;
                       }

                   }
               }
           case "KONST": //Tablica konstanti
               {
                   gornja_granica = KONST_List.Count;
                   while (true)
                   {
                       srednji = (int)((donja_granica + gornja_granica) / 2);
                       if (KONST_List[srednji].Give_Back_pokazivac() == vrijednost)
                       {
                           return srednji;
                       }
                       if (donja_granica >= gornja_granica)
                       {
                           return 0;
                       }
                       if (KONST_List[srednji].Give_Back_pokazivac() < vrijednost)
                       {
                           donja_granica = srednji + 1;
                       }
                       if (KONST_List[srednji].Give_Back_pokazivac() > vrijednost)
                       {
                           gornja_granica = srednji - 1;
                       }

                   }
               }
           default:
               return 0;
       };
   }
    


}

public class C_Details
{
    public int pokazivac;
    public string naziv;
    public string tip;
    public int redak;
    public string klasa;

    public C_Details(int pokazivac, string naziv, string tip, int redak, string klasa)
    {
        this.pokazivac = pokazivac;
        this.naziv = naziv;
        this.tip = tip;
        this.redak = redak;
        this.klasa = klasa;
    }
}

public class TUZ
{

    public List<C_UNIFORM_Z> UNIFORM_Z_List;

    private int SljedProcZnak;
    
    public string SljedZnak()
    {
        string sljed_znak;
        if (this.UNIFORM_Z_List.Count>this.SljedProcZnak) sljed_znak = this.UNIFORM_Z_List[SljedProcZnak].Give_Back_Klasa();
        else return "EOF";
        if (sljed_znak == "KROS") sljed_znak = this.naziv(SljedProcZnak, Lists); 
        this.SljedProcZnak++;
        return sljed_znak;
        
    }

    public TUZ()
    {
        this.UNIFORM_Z_List = new List<C_UNIFORM_Z>();
        this.SljedProcZnak = 0;
    }


    public void Add_Unif_Konst(ULAZ ulazno_Polje, Liste Lists, string tip_K){
	
	int pointer = 0;
	string name = ulazno_Polje.izvorno;

	pointer = Lists.Find_Indx(name, 3); //3 je switch za KON
                                if (pointer != 0) // dodaj u TUZ, povezi
                                {
                                    UNIFORM_Z_List.Add(new C_UNIFORM_Z(ulazno_Polje.uniformno, pointer, ulazno_Polje.redak));
                                }
                                else //dodaj u tab konst, dodaj u TUZ, povezi
                                {
                                    Adr_KONS++;
                                    Lists.KONST_List.Add(new C_KONST(Adr_KONS, name, tip_K));
                                    UNIFORM_Z_List.Add(new C_UNIFORM_Z(ulazno_Polje.uniformno, Adr_KONS, ulazno_Polje.redak));
                                }
	}
    

	
    public void Add_Unif_Ident(ULAZ ulazno_Polje, Liste Lists){
	
	string name = ulazno_Polje.izvorno;
	int pointer = 0;

	pointer = Lists.Find_Indx(name, 2); // 2 je switch za IDENT
                        if (pointer != 0) // dodaj u TUZ, povezi
                        {
                            UNIFORM_Z_List.Add(new C_UNIFORM_Z(ulazno_Polje.uniformno, pointer, ulazno_Polje.redak));
                        }
                        else //dodaj u tab ident, dodaj u TUZ, povezi
                        {
                            Adr_IDN++;
                            Lists.IDENT_List.Add(new C_IDENT(Adr_IDN, name, ""));
                            UNIFORM_Z_List.Add(new C_UNIFORM_Z(ulazno_Polje.uniformno, Adr_IDN, ulazno_Polje.redak));
                        }
	}


    public void Add_Unif_KROS(ULAZ ulazno_Polje, Liste Lists){
	
	int pointer = 0;
	string name = ulazno_Polje.izvorno;

	 pointer = Lists.Find_Indx(name, 1); // 1 je switch za KROS
                                
	if (pointer != 0)
                        {
                            UNIFORM_Z_List.Add(new C_UNIFORM_Z(ulazno_Polje.uniformno, pointer, ulazno_Polje.redak));
                        }else{
			//greska
		}
    }

           public void Ispis()
    {
        for (int i = 0; i < UNIFORM_Z_List.Count; i++)
        {
            UNIFORM_Z_List[i].PrintToConsole();
        }
       
    }
           private void Search_for_Details(int POK, Liste Lists, ref C_Details detalji)
           {
               int pokazivac = 0;
               if (UNIFORM_Z_List[POK].Give_Back_Klasa() == "KROS")
               {
                   pokazivac = Lists.Binary_Search_for_Index("KROS", UNIFORM_Z_List[POK].Give_Back_Pokazivac());
                   if (pokazivac >= 0)
                   {
                       detalji.naziv = Lists.KROS_List[pokazivac].Give_Back_naziv();
                       detalji.tip = "";
                       detalji.pokazivac = POK;
                       detalji.redak = UNIFORM_Z_List[POK].Give_Back_Redak();
                       detalji.klasa = "KROS";
                   }
                   else
                   {
                       //pogreska
                   }
               }
               if (UNIFORM_Z_List[POK].Give_Back_Klasa() == "KONST")
               {
                   pokazivac = Lists.Binary_Search_for_Index("KONST", UNIFORM_Z_List[POK].Give_Back_Pokazivac());
                   if (pokazivac >= 0)
                   {
                       detalji.naziv = Lists.KONST_List[pokazivac].Give_Back_vrijednost();
                       detalji.tip = Lists.KONST_List[pokazivac].Give_Back_tip();
                       detalji.pokazivac = POK;
                       detalji.redak = UNIFORM_Z_List[POK].Give_Back_Redak();
                       detalji.klasa = "KONST";
                   }
                   else
                   {
                       //pogreska
                   }
               }
               if (UNIFORM_Z_List[POK].Give_Back_Klasa() == "IDENT")//promijeniti u Identifikator
               {
                   pokazivac = Lists.Binary_Search_for_Index("IDENT", UNIFORM_Z_List[POK].Give_Back_Pokazivac());
                   if (pokazivac >= 0)
                   {
                       detalji.naziv = Lists.IDENT_List[pokazivac].Give_Back_naziv();
                       detalji.tip = Lists.IDENT_List[pokazivac].Give_Back_tip();
                       detalji.pokazivac = POK;
                       detalji.redak = UNIFORM_Z_List[POK].Give_Back_Redak();
                       detalji.klasa = "IDENT";
                   }
                   else
                   {
                       //pogreska
                   }
               }
           }
           public string naziv(int POK, Liste Lists)
           {
               C_Details pom_detalji = new C_Details(0, "", "", 0, "");
               this.Search_for_Details(POK, Lists, ref pom_detalji);
               return pom_detalji.naziv;
           }
           public string tip(int POK, Liste Lists)
           {
               if (UNIFORM_Z_List[POK].Give_Back_Klasa() == "IDENT" || UNIFORM_Z_List[POK].Give_Back_Klasa() == "KONST")
               {
                   C_Details pom_detalji = new C_Details(0, "", "", 0, "");
                   this.Search_for_Details(POK, Lists, ref pom_detalji);
                   return pom_detalji.tip;
               }
               else return "";
           }
           public string klasa(int POK, Liste Lists)
           {
               C_Details pom_detalji = new C_Details(0, "", "", 0, "");
               this.Search_for_Details(POK, Lists, ref pom_detalji);
               return pom_detalji.klasa;
           }
           public void postavi_tip(int POK, Liste Lists, string novi_tip)
           {
               int pokazivac = 0;
               if (UNIFORM_Z_List[POK].Give_Back_Klasa() == "KONST")
               {
                   pokazivac = Lists.Binary_Search_for_Index("KROS", UNIFORM_Z_List[POK].Give_Back_Pokazivac());
                   if (pokazivac != 0)
                   {
                       Lists.KONST_List[pokazivac].Set_tip(novi_tip);
                   }
                   else
                   {
                       //pogreska
                   }
               }
               if (UNIFORM_Z_List[POK].Give_Back_Klasa() == "Identifikator")
               {
                   pokazivac = Lists.Binary_Search_for_Index("Identifikator", UNIFORM_Z_List[POK].Give_Back_Pokazivac());
                   if (pokazivac != 0)
                   {
                       Lists.IDENT_List[pokazivac].Set_tip(novi_tip);
                   }
                   else
                   {
                       //pogreska
                   }
               }
               else
               {
                   //pogreska
               }

           } 
}

public class ULAZ
{
    public string izvorno;
    public string uniformno;
    public int redak;

	public ULAZ(){
	}
	public  void  Dodaj_izvorno(string izv){
	izvorno = izv;
	}

	public  void  Dodaj_uniformno(string unif){
	uniformno = unif;
	}
	public  void  Dodaj_redak(int red){
	redak = red;
	}

    // Constructor
    public ULAZ(string izvorno, string uniformno, int redak)
    {
        this.izvorno = izvorno;
        this.uniformno = uniformno;
        this.redak = redak;
    }
}
        int state;
        int currentStart = initial;
        int chr;           // last character read
        int cNum = 0;      // ordinal number of chr
        int lNum = 0;      // current line number
        int lineStartNum;  // ordinal number at start of line
        //
        // The following instance variables are used, among other
        // things, for constructing the yylloc location objects.
        //
        int tokPos;        // buffer position at start of token
        int tokNum;        // ordinal number of first character
        int tokLen;        // number of characters in token
        int tokCol;        // zero-based column number at start of token
        int tokLin;        // line number at start of token
        int tokEPos;       // buffer position at end of token
        int tokECol;       // column number at end of token
        int tokELin;       // line number at end of token
        string tokTxt;     // lazily constructed text of token
#if STACK          
        private Stack<int> scStack = new Stack<int>();
#endif // STACK

#region ScannerTables
    struct Table {
        public int min; public int rng; public int dflt;
        public sbyte[] nxt;
        public Table(int m, int x, int d, sbyte[] n) {
            min = m; rng = x; dflt = d; nxt = n;
        }
    };

    static int[] startState = {102, 102, 102, 0};

    static Table[] NxS = new Table[105];

    static Scanner() {
    NxS[0] = new Table(0, 0, 0, null); // Shortest string ""
    NxS[1] = new Table(0, 0, -1, null); // Shortest string "|"
    NxS[2] = new Table(0, 0, -1, null); // Shortest string "\001"
    NxS[3] = new Table(0, 0, -1, null); // Shortest string "\t"
    NxS[4] = new Table(0, 0, -1, null); // Shortest string "\n"
    NxS[5] = // Shortest string "\r"
      new Table(10, 1, -1, new sbyte[] {4});
    NxS[6] = // Shortest string "!"
      new Table(61, 1, -1, new sbyte[] {101});
    NxS[7] = // Shortest string "&"
      new Table(38, 1, -1, new sbyte[] {100});
    NxS[8] = // Shortest string "'"
      new Table(65, 58, -1, new sbyte[] {104, 104, 104, 104, 104, 104, 
          104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 
          104, 104, 104, 104, -1, -1, -1, -1, -1, -1, 104, 104, 104, 104, 104, 104, 
          104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 
          104, 104, 104, 104});
    NxS[9] = new Table(0, 0, -1, null); // Shortest string "("
    NxS[10] = new Table(0, 0, -1, null); // Shortest string ")"
    NxS[11] = new Table(0, 0, -1, null); // Shortest string "*"
    NxS[12] = new Table(0, 0, -1, null); // Shortest string "+"
    NxS[13] = new Table(0, 0, -1, null); // Shortest string ","
    NxS[14] = new Table(0, 0, -1, null); // Shortest string "-"
    NxS[15] = new Table(0, 0, -1, null); // Shortest string "."
    NxS[16] = // Shortest string "/"
      new Table(60, 1, -1, new sbyte[] {103});
    NxS[17] = // Shortest string "0"
      new Table(46, 12, -1, new sbyte[] {97, -1, 17, 17, 17, 17, 
          17, 17, 17, 17, 17, 17});
    NxS[18] = new Table(0, 0, -1, null); // Shortest string ":"
    NxS[19] = new Table(0, 0, -1, null); // Shortest string ";"
    NxS[20] = new Table(0, 0, -1, null); // Shortest string "<"
    NxS[21] = // Shortest string "="
      new Table(61, 1, -1, new sbyte[] {96});
    NxS[22] = // Shortest string ">"
      new Table(61, 1, -1, new sbyte[] {95});
    NxS[23] = // Shortest string "A"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[24] = new Table(0, 0, -1, null); // Shortest string "["
    NxS[25] = new Table(0, 0, -1, null); // Shortest string "]"
    NxS[26] = // Shortest string "b"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 91, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[27] = // Shortest string "c"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 81, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 82, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[28] = // Shortest string "d"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 74, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 75, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[29] = // Shortest string "e"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 71, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[30] = // Shortest string "f"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 62, 23, 23, 23, 23, 23, 63, 
          23, 23, 23, 23, 23});
    NxS[31] = // Shortest string "i"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          61, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[32] = // Shortest string "n"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 59, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[33] = // Shortest string "r"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 54, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[34] = // Shortest string "s"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 49, 23, 23, 23});
    NxS[35] = // Shortest string "t"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 46, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[36] = // Shortest string "v"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 44, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[37] = // Shortest string "w"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 40, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[38] = new Table(0, 0, -1, null); // Shortest string "{"
    NxS[39] = new Table(0, 0, -1, null); // Shortest string "}"
    NxS[40] = // Shortest string "wh"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 41, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[41] = // Shortest string "whi"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 42, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[42] = // Shortest string "whil"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 43, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[43] = // Shortest string "while"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[44] = // Shortest string "va"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 45, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[45] = // Shortest string "var"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[46] = // Shortest string "th"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 47, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[47] = // Shortest string "thi"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 48, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[48] = // Shortest string "this"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[49] = // Shortest string "sw"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 50, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[50] = // Shortest string "swi"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 51, 23, 
          23, 23, 23, 23, 23});
    NxS[51] = // Shortest string "swit"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 52, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[52] = // Shortest string "switc"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 53, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[53] = // Shortest string "switch"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[54] = // Shortest string "re"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 55, 23, 
          23, 23, 23, 23, 23});
    NxS[55] = // Shortest string "ret"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 56, 
          23, 23, 23, 23, 23});
    NxS[56] = // Shortest string "retu"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 57, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[57] = // Shortest string "retur"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 58, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[58] = // Shortest string "return"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[59] = // Shortest string "ne"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 60, 23, 23, 23});
    NxS[60] = // Shortest string "new"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[61] = // Shortest string "if"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[62] = // Shortest string "fo"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 70, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[63] = // Shortest string "fu"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 64, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[64] = // Shortest string "fun"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 65, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[65] = // Shortest string "func"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 66, 23, 
          23, 23, 23, 23, 23});
    NxS[66] = // Shortest string "funct"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 67, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[67] = // Shortest string "functi"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 68, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[68] = // Shortest string "functio"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 69, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[69] = // Shortest string "function"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[70] = // Shortest string "for"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[71] = // Shortest string "el"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 72, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[72] = // Shortest string "els"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 73, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[73] = // Shortest string "else"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[74] = // Shortest string "de"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          76, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[75] = // Shortest string "do"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[76] = // Shortest string "def"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 77, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[77] = // Shortest string "defa"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 78, 
          23, 23, 23, 23, 23});
    NxS[78] = // Shortest string "defau"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 79, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[79] = // Shortest string "defaul"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 80, 23, 
          23, 23, 23, 23, 23});
    NxS[80] = // Shortest string "default"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[81] = // Shortest string "ca"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 89, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[82] = // Shortest string "co"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 83, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[83] = // Shortest string "con"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 84, 23, 
          23, 23, 23, 23, 23});
    NxS[84] = // Shortest string "cont"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 85, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[85] = // Shortest string "conti"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 86, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[86] = // Shortest string "contin"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 87, 
          23, 23, 23, 23, 23});
    NxS[87] = // Shortest string "continu"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 88, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[88] = // Shortest string "continue"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[89] = // Shortest string "cas"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 90, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[90] = // Shortest string "case"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[91] = // Shortest string "br"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 92, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[92] = // Shortest string "bre"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 93, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[93] = // Shortest string "brea"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 94, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[94] = // Shortest string "break"
      new Table(48, 75, -1, new sbyte[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[95] = new Table(0, 0, -1, null); // Shortest string ">="
    NxS[96] = new Table(0, 0, -1, null); // Shortest string "=="
    NxS[97] = // Shortest string "0."
      new Table(48, 10, -1, new sbyte[] {97, 97, 97, 97, 97, 97, 
          97, 97, 97, 97});
    NxS[98] = new Table(0, 0, -1, null); // Shortest string "/<="
    NxS[99] = new Table(0, 0, -1, null); // Shortest string "'A'"
    NxS[100] = new Table(0, 0, -1, null); // Shortest string "&&"
    NxS[101] = new Table(0, 0, -1, null); // Shortest string "!="
    NxS[102] = // Shortest string ""
      new Table(0, 126, 2, new sbyte[] {1, 2, 2, 2, 2, 2, 
          2, 2, 2, 3, 4, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 6, 3, 2, 2, 2, 
          7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 
          17, 17, 17, 17, 18, 19, 20, 21, 22, 2, 2, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 24, 2, 25, 2, 2, 2, 23, 26, 27, 28, 29, 
          30, 23, 23, 31, 23, 23, 23, 23, 32, 23, 23, 23, 33, 34, 35, 23, 
          36, 37, 23, 23, 23, 38, 1, 39});
    NxS[103] = // Shortest string "/<"
      new Table(61, 1, -1, new sbyte[] {98});
    NxS[104] = // Shortest string "'A"
      new Table(39, 84, -1, new sbyte[] {99, -1, -1, -1, -1, -1, 
          -1, -1, -1, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, -1, -1, -1, 
          -1, -1, -1, -1, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 
          104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, -1, -1, 
          -1, -1, -1, -1, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 
          104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104});
    }

int NextState(int qStat) {
    if (chr == ScanBuff.EOF)
        return (qStat <= maxAccept && qStat != currentStart ? currentStart : eofNum);
    else {
        int rslt;
        int idx = (byte)(chr - NxS[qStat].min);
        if ((uint)idx >= (uint)NxS[qStat].rng) rslt = NxS[qStat].dflt;
        else rslt = NxS[qStat].nxt[idx];
        return (rslt == goStart ? currentStart : rslt);
    }
}

int NextState() {
    if (chr == ScanBuff.EOF)
        return (state <= maxAccept && state != currentStart ? currentStart : eofNum);
    else {
        int rslt;
        int idx = (byte)(chr - NxS[state].min);
        if ((uint)idx >= (uint)NxS[state].rng) rslt = NxS[state].dflt;
        else rslt = NxS[state].nxt[idx];
        return (rslt == goStart ? currentStart : rslt);
    }
}
#endregion


#if BACKUP
        // ====================== Nested class ==========================

        internal class Context // class used for automaton backup.
        {
            public int bPos;
            public int cNum;
            public int state;
            public int cChr;
        }
#endif // BACKUP

        // ==============================================================
        // ===== Nested classes for various ScanBuff derived classes ====
        // ==============================================================

        public sealed class StringBuff : ScanBuff
        {
            string str;        // input buffer
            int bPos;          // current position in buffer
            int sLen;

            public StringBuff(string str)
            {
                this.str = str;
                this.sLen = str.Length;
            }

            public override int Read()
            {
                if (bPos < sLen) return str[bPos++];
#if BABEL
                else if (bPos == sLen) { bPos++; return '\n'; }   // one strike, see newline
#endif // BABEL
                else { bPos++; return EOF; }                      // two strikes and you're out!
            }
            
            public override int ReadPos { get { return bPos - 1; } }

            public override int Peek()
            {
                if (bPos < sLen) return str[bPos];
                else return '\n';
            }

            public override string GetString(int beg, int end)
            {
                //  "end" can be greater than sLen with the BABEL
                //  option set.  Read returns a "virtual" EOL if
                //  an attempt is made to read past the end of the
                //  string buffer.  Without the guard any attempt 
                //  to fetch yytext for a token that includes the 
                //  EOL will throw an index exception.
                if (end > sLen) end = sLen;
                if (end <= beg) return ""; 
                else return str.Substring(beg, end - beg);
            }

            public override int Pos
            {
                get { return bPos; }
                set { bPos = value; }
            }
        }

       // ====================== Nested class ==========================
       //  The LineBuff class contributed by Nigel Horspool, 
       //  nigelh@cs.uvic.cs
       // ==============================================================

        public sealed class LineBuff : ScanBuff
        {
            IList<string> line;    // list of source lines from a file
            int numLines;          // number of strings in line list
            string curLine;        // current line in that list
            int cLine;             // index of current line in the list
            int curLen;            // length of current line
            int curLineStart;      // position of line start in whole file
            int curLineEnd;        // position of line end in whole file
            int maxPos;            // max position ever visited in whole file
            int cPos;              // ordinal number of chr in source

            // Constructed from a list of strings, one per source line.
            // The lines have had trailing '\n' characters removed.
            public LineBuff(IList<string> lineList)
            {
                line = lineList;
                numLines = line.Count;
                cPos = curLineStart = 0;
                curLine = numLines>0? line[0] : "";
                maxPos = curLineEnd = curLen = curLine.Length;
                cLine = 1;
            }

            public override int Read()
            {
                if (cPos < curLineEnd)
                    return curLine[cPos++ - curLineStart];
                if (cPos++ == curLineEnd)
                    return '\n';
                if (cLine >= numLines)
                    return EOF;
                curLine = line[cLine];
                curLen = curLine.Length;
                curLineStart = curLineEnd + 1;
                curLineEnd = curLineStart + curLen;
                if (curLineEnd>maxPos)
                    maxPos = curLineEnd;
                cLine++;
                return curLen>0? curLine[0] : '\n';
            }

            public override int Peek()
            {
                return (cPos < curLineEnd)? curLine[cPos - curLineStart] : '\n';
            }

            // To speed up searches for the line containing a position
            private int cachedPos = 0;
            private int cachedIx = 0;
            private int cachedLstart = 0;

            // Given a position pos within the entire source, the results are
            //   ix     -- the index of the containing line
            //   lstart -- the position of the first character on that line
            private void findIndex( int pos, out int ix, out int lstart )
            {
                if (pos >= cachedPos) {
                    ix = cachedIx;  lstart = cachedLstart;
                } else {
                    ix = lstart = 0;
                }
                for( ; ; ) {
                    int len = line[ix].Length + 1;
                    if (pos < lstart+len) break;
                    lstart += len;
                    ix++;
                }
                cachedPos = pos;
                cachedIx = ix;
                cachedLstart = lstart;
            }
        
            public override string GetString(int beg, int end)
            {
                if (beg >= maxPos || end <= beg) return "";
                int endIx, begIx, endLineStart, begLineStart;
                findIndex(beg, out begIx, out begLineStart);
                int begCol = beg - begLineStart;
                findIndex(end, out endIx, out endLineStart);
                int endCol = end - endLineStart;
                string s = line[begIx];
                if (begIx == endIx) {
                    // the usual case, substring all on one line
                    return (endCol <= s.Length)?
                        s.Substring(begCol, endCol-begCol)
                        : s.Substring(begCol) + "\n";
                }
                // the string spans multiple lines, yuk!
                StringBuilder sb = new StringBuilder();
                if (begCol < s.Length)
                    sb.Append(s.Substring(begCol));
                for( ; ; ) {
                    sb.Append("\n");
                    s = line[++begIx];
                    if (begIx >= endIx) break;
                    sb.Append(s);
                }
                if (endCol <= s.Length) {
                    sb.Append(s.Substring(0, endCol));
                } else {
                    sb.Append(s);
                    sb.Append("\n");
                }
                return sb.ToString();
            }

            public override int Pos
            {
                get { return cPos; }
                set {
                    cPos = value;
                    findIndex(cPos, out cLine, out curLineStart);
                    curLine = line[cLine];
                    curLineEnd = curLineStart+curLine.Length;
                }
            }
            
            public override int ReadPos { get { return cPos - 1; } }
        }
        
        // ====================== Nested class ==========================

        public sealed class StreamBuff : ScanBuff
        {
            BufferedStream bStrm;   // input buffer
            int delta = 1;          // number of bytes in chr, could be 0 for EOF.

            public StreamBuff(Stream str) { this.bStrm = new BufferedStream(str); }

            public override int Read() {
                int ch0 = bStrm.ReadByte();
                delta = (ch0 == EOF ? 0 : 1);
                return ch0; 
            }
            
            public override int ReadPos {
                get { return (int)bStrm.Position - delta; }
            }

            public override int Peek()
            {
                int rslt = bStrm.ReadByte();
                bStrm.Seek(-delta, SeekOrigin.Current);
                return rslt;
            }

            public override string GetString(int beg, int end)
            {
                if (end - beg <= 0) return "";
                long savePos = bStrm.Position;
                char[] arr = new char[end - beg];
                bStrm.Position = (long)beg;
                for (int i = 0; i < (end - beg); i++)
                    arr[i] = (char)bStrm.ReadByte();
                bStrm.Position = savePos;
                return new String(arr);
            }

            // Pos is the position *after* reading chr!
            public override int Pos
            {
                get { return (int)bStrm.Position; }
                set { bStrm.Position = value; }
            }
        }

        // ====================== Nested class ==========================

        /// <summary>
        /// This is the Buffer for UTF8 files.
        /// It attempts to read the encoding preamble, which for 
        /// this encoding should be unicode point \uFEFF which is 
        /// encoded as EF BB BF
        /// </summary>
        public class TextBuff : ScanBuff
        {
            protected BufferedStream bStrm;   // input buffer
            protected int delta = 1;          // length of chr, zero for EOF!
            
            private Exception BadUTF8()
            { return new Exception(String.Format("BadUTF8 Character")); }

            /// <summary>
            /// TextBuff factory.  Reads the file preamble
            /// and returns a TextBuff, LittleEndTextBuff or
            /// BigEndTextBuff according to the result.
            /// </summary>
            /// <param name="strm">The underlying stream</param>
            /// <returns></returns>
            public static TextBuff NewTextBuff(Stream strm)
            {
                // First check if this is a UTF16 file
                //
                int b0 = strm.ReadByte();
                int b1 = strm.ReadByte();

                if (b0 == 0xfe && b1 == 0xff)
                    return new BigEndTextBuff(strm);
                if (b0 == 0xff && b1 == 0xfe)
                    return new LittleEndTextBuff(strm);
                
                int b2 = strm.ReadByte();
                if (b0 == 0xef && b1 == 0xbb && b2 == 0xbf)
                    return new TextBuff(strm);
                //
                // There is no unicode preamble, so we
                // must go back to the UTF8 default.
                //
                strm.Seek(0, SeekOrigin.Begin);
                return new TextBuff(strm);
            }

            protected TextBuff(Stream str) { 
                this.bStrm = new BufferedStream(str);
            }

            public override int Read()
            {
                int ch0 = bStrm.ReadByte();
                int ch1;
                int ch2;
                if (ch0 < 0x7f)
                {
                    delta = (ch0 == EOF ? 0 : 1);
                    return ch0;
                }
                else if ((ch0 & 0xe0) == 0xc0)
                {
                    delta = 2;
                    ch1 = bStrm.ReadByte();
                    if ((ch1 & 0xc0) == 0x80)
                        return ((ch0 & 0x1f) << 6) + (ch1 & 0x3f);
                    else
                        throw BadUTF8();
                }
                else if ((ch0 & 0xf0) == 0xe0)
                {
                    delta = 3;
                    ch1 = bStrm.ReadByte();
                    ch2 = bStrm.ReadByte();
                    if ((ch1 & ch2 & 0xc0) == 0x80)
                        return ((ch0 & 0xf) << 12) + ((ch1 & 0x3f) << 6) + (ch2 & 0x3f);
                    else
                        throw BadUTF8();
                }
                else
                    throw BadUTF8();
            }

            public sealed override int ReadPos
            {
                get { return (int)bStrm.Position - delta; }
            }

            public sealed override int Peek()
            {
                int rslt = Read();
                bStrm.Seek(-delta, SeekOrigin.Current);
                return rslt;
            }

            /// <summary>
            /// Returns the string from the buffer between
            /// the given file positions.  This needs to be
            /// done carefully, as the number of characters
            /// is, in general, not equal to (end - beg).
            /// </summary>
            /// <param name="beg">Begin filepos</param>
            /// <param name="end">End filepos</param>
            /// <returns></returns>
            public sealed override string GetString(int beg, int end)
            {
                int i;
                if (end - beg <= 0) return "";
                long savePos = bStrm.Position;
                char[] arr = new char[end - beg];
                bStrm.Position = (long)beg;
                for (i = 0; bStrm.Position < end; i++)
                    arr[i] = (char)Read();
                bStrm.Position = savePos;
                return new String(arr, 0, i);
            }

            // Pos is the position *after* reading chr!
            public sealed override int Pos
            {
                get { return (int)bStrm.Position; }
                set { bStrm.Position = value; }
            }
        }

        // ====================== Nested class ==========================
        /// <summary>
        /// This is the Buffer for Big-endian UTF16 files.
        /// </summary>
        public sealed class BigEndTextBuff : TextBuff
        {
            internal BigEndTextBuff(Stream str) : base(str) { } // 

            public override int Read()
            {
                int ch0 = bStrm.ReadByte();
                int ch1 = bStrm.ReadByte();
                if (ch1 == EOF)
                {
                    // An EOF in either byte counts as an EOF
                    delta = (ch0 == EOF ? 0 : 1);
                    return -1;
                }
                else
                {
                    delta = 2;
                    return (ch0 << 8) + ch1;
                }
            }
        }
        
        // ====================== Nested class ==========================
        /// <summary>
        /// This is the Buffer for Little-endian UTF16 files.
        /// </summary>
        public sealed class LittleEndTextBuff : TextBuff
        {
            internal LittleEndTextBuff(Stream str) : base(str) { } // { this.bStrm = new BufferedStream(str); }

            public override int Read()
            {
                int ch0 = bStrm.ReadByte();
                int ch1 = bStrm.ReadByte();
                if (ch1 == EOF)
                {
                    // An EOF in either byte counts as an EOF
                    delta = (ch0 == EOF ? 0 : 1);
                    return -1;
                }
                else
                {
                    delta = 2;
                    return (ch1 << 8) + ch1;
                }
            }
        }
        // =================== End Nested classes =======================

        public Scanner(Stream file) {
            buffer = new StreamBuff(file);
            this.cNum = -1;
            this.chr = '\n'; // to initialize yyline, yycol and lineStart
            GetChr();
        }

        public Scanner() { }

        void GetChr()
        {
            if (chr == '\n') 
            { 
                lineStartNum = cNum + 1; 
                lNum++; 
            }
            chr = buffer.Read();
            cNum++;
        }

        void MarkToken()
        {
            tokPos = buffer.ReadPos;
            tokNum = cNum;
            tokLin = lNum;
            tokCol = cNum - lineStartNum;
        }
        
        void MarkEnd()
        {
            tokTxt = null;
            tokLen = cNum - tokNum;
            tokEPos = buffer.ReadPos;
            tokELin = lNum;
            tokECol = cNum - lineStartNum;
        }

        // ==============================================================
        // =====    Initialization of string-based input buffers     ====
        // ==============================================================

        public void SetSource(string source, int offset)
        {
            this.buffer = new StringBuff(source);
            this.buffer.Pos = offset;
            this.cNum = offset - 1;
            this.chr = '\n'; // to initialize yyline, yycol and lineStart
            GetChr();
        }
        
        // ================ LineBuffer Initialization ===================

        public void SetSource(IList<string> source)
        {
            this.buffer = new LineBuff(source);
            this.chr = '\n'; // to initialize yyline, yycol and lineStart
            this.cNum = -1;
            GetChr();
        }
        
        // ==============================================================

#if BABEL
        //
        //  Get the next token for Visual Studio
        //
        //  "state" is the inout mode variable that maintains scanner
        //  state between calls, using the EolState property. In principle,
        //  if the calls of EolState are costly set could be called once
        //  only per line, at the start; and get called only at the end
        //  of the line. This needs more infrastructure ...
        //
        public int GetNext(ref int state, out int start, out int end)
        {
            Tokens next;
            int s, e;
            s = state;        // state at start
            EolState = state;
            next = (Tokens)Scan();
            state = EolState;
            e = state;       // state at end;
            start = tokPos;
            end = tokEPos - 1; // end is the index of last char.
            return (int)next;
        }        
#endif // BABEL

        // ======== IScanner<> Implementation =========

        public override int yylex()
        {
            // parserMax is set by reflecting on the Tokens
            // enumeration.  If maxParseTokeen is defined
            // that is used, otherwise int.MaxValue is used.
            int next;
            do { next = Scan(); } while (next >= parserMax);
            return next;
        }
        
        int yyleng { get { return tokLen; } }
        int yypos { get { return tokPos; } }
        int yyline { get { return tokLin; } }
        int yycol { get { return tokCol; } }

        public string yytext
        {
            get 
            {
                if (tokTxt == null) 
                    tokTxt = buffer.GetString(tokPos, tokEPos);
                return tokTxt;
            }
        }

        void yyless(int n) { 
            buffer.Pos = tokPos;
            // Must read at least one char, so set before start.
            cNum = tokNum - 1;
            for (int i = 0; i <= n; i++) GetChr();
            MarkEnd();
        }

        // ============ methods available in actions ==============

        internal int YY_START {
            get { return currentScOrd; }
            set { currentScOrd = value; } 
        }
        
        internal void BEGIN(int next) {
            currentScOrd = next;
            currentStart = startState[next];
        }

        // ============== The main tokenizer code =================

        int Scan()
        {
// local variables
                for (; ; )
                {
                    int next;              // next state to enter                   
#if BACKUP
                    bool inAccept = false; // inAccept ==> current state is an accept state
                    Result rslt = Result.noMatch;
                    // skip "idle" transitions
#if LEFTANCHORS
                    if (lineStartNum == cNum && NextState(anchorState[currentScOrd]) != currentStart)
                        state = anchorState[currentScOrd];
                    else {
                        state = currentStart;
                        while (NextState() == state) {
                            GetChr();
                            if (lineStartNum == cNum) {
                                int anchor = anchorState[currentScOrd];
                                if (NextState(anchor) != state) {
                                    state = anchor; 
                                    break;
                                }
                            }
                        }
                    }
#else // !LEFTANCHORS
                    state = currentStart;
                    while (NextState() == state) 
                        GetChr(); // skip "idle" transitions
#endif // LEFTANCHORS
                    MarkToken();
                    
                    while ((next = NextState()) != currentStart)
                        if (inAccept && next > maxAccept) // need to prepare backup data
                        {
                            Context ctx = new Context();
                            rslt = Recurse2(ctx, next);
                            if (rslt == Result.noMatch) RestoreStateAndPos(ctx);
                            break;
                        }
                        else
                        {
                            state = next;
                            GetChr();
                            if (state <= maxAccept) inAccept = true;
                        }
#else // !BACKUP
#if LEFTANCHORS
                    if (lineStartNum == cNum) {
                        int anchor = anchorState[currentScOrd];
                        if (NextState(anchor) != currentStart)
                            state = anchor;
                    }
                    else {
                        state = currentStart;
                        while (NextState() == state) {
                            GetChr();
                            if (lineStartNum == cNum) {
                                int anchor = anchorState[currentScOrd];
                                if (NextState(anchor) != state) {
                                    state = anchor;
                                    break;
                                }
                            }
                        }
                    }
#else // !LEFTANCHORS
                    state = currentStart;
                    while (NextState() == state) 
                        GetChr(); // skip "idle" transitions
#endif // LEFTANCHORS
                    MarkToken();
                    // common code
                    while ((next = NextState()) != currentStart)
                    {
                        state = next;
                        GetChr();
                    }
#endif // BACKUP
                    if (state > maxAccept) 
                        state = currentStart;
                    else
                    {
                        MarkEnd();
#region ActionSwitch
#pragma warning disable 162
    switch (state)
    {
        case eofNum:
            return (int)Tokens.EOF;
        case 1:
ulazno_Polje.Dodaj_izvorno("OR"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 2:
        case 7:
        case 8:
Glavni.Ispisi("Greska: nepoznata leksicka jedinka u retku "+lineTot);
            break;
        case 3:
{}
            break;
        case 4:
        case 5:
lineTot++;
            break;
        case 6:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 9:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 10:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 11:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 12:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 13:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 14:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 15:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 16:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 17:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KONST");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_Konst(ulazno_Polje, Lists, "cijeli");
            break;
        case 18:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 19:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 20:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 21:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 22:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 23:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 40:
        case 41:
        case 42:
        case 44:
        case 46:
        case 47:
        case 49:
        case 50:
        case 51:
        case 52:
        case 54:
        case 55:
        case 56:
        case 57:
        case 59:
        case 62:
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
        case 71:
        case 72:
        case 74:
        case 76:
        case 77:
        case 78:
        case 79:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 89:
        case 91:
        case 92:
        case 93:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("IDENT");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_Ident(ulazno_Polje, Lists);
            break;
        case 24:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 25:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 38:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 39:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 43:
ulazno_Polje.Dodaj_izvorno("WHILE"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 45:
ulazno_Polje.Dodaj_izvorno("VAR"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 48:
ulazno_Polje.Dodaj_izvorno("THIS"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 53:
ulazno_Polje.Dodaj_izvorno("SWITCH"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 58:
ulazno_Polje.Dodaj_izvorno("RETURN"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 60:
ulazno_Polje.Dodaj_izvorno("NEW"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 61:
ulazno_Polje.Dodaj_izvorno("IF"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 69:
ulazno_Polje.Dodaj_izvorno("FUNCTION"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 70:
ulazno_Polje.Dodaj_izvorno("FOR"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 73:
ulazno_Polje.Dodaj_izvorno("ELSE"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 75:
ulazno_Polje.Dodaj_izvorno("DO"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 80:
ulazno_Polje.Dodaj_izvorno("DEFAULT"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 88:
ulazno_Polje.Dodaj_izvorno("CONTINUE"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 90:
ulazno_Polje.Dodaj_izvorno("CASE"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 94:
ulazno_Polje.Dodaj_izvorno("BREAK"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 95:
ulazno_Polje.Dodaj_izvorno("GE"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 96:
ulazno_Polje.Dodaj_izvorno("EQ"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 97:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KONST");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_Konst(ulazno_Polje, Lists, "decimalni");
            break;
        case 98:
ulazno_Polje.Dodaj_izvorno("LE"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 99:
ulazno_Polje.Dodaj_izvorno(yytext); ulazno_Polje.Dodaj_uniformno("KONST");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_Konst(ulazno_Polje, Lists, "string");
            break;
        case 100:
ulazno_Polje.Dodaj_izvorno("AND"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        case 101:
ulazno_Polje.Dodaj_izvorno("NEQ"); ulazno_Polje.Dodaj_uniformno("KROS");  ulazno_Polje.Dodaj_redak(lineTot); Tabl_unif_znak.Add_Unif_KROS(ulazno_Polje, Lists);
            break;
        default:
            break;
    }
#pragma warning restore 162
#endregion
                    }
                }
        }

#if BACKUP
        Result Recurse2(Context ctx, int next)
        {
            // Assert: at entry "state" is an accept state AND
            //         NextState(state, chr) != currentStart AND
            //         NextState(state, chr) is not an accept state.
            //
            bool inAccept;
            SaveStateAndPos(ctx);
            state = next;
            if (state == eofNum) return Result.accept;
            GetChr();
            inAccept = false;

            while ((next = NextState()) != currentStart)
            {
                if (inAccept && next > maxAccept) // need to prepare backup data
                    SaveStateAndPos(ctx);
                state = next;
                if (state == eofNum) return Result.accept;
                GetChr(); 
                inAccept = (state <= maxAccept);
            }
            if (inAccept) return Result.accept; else return Result.noMatch;
        }

        void SaveStateAndPos(Context ctx)
        {
            ctx.bPos  = buffer.Pos;
            ctx.cNum  = cNum;
            ctx.state = state;
            ctx.cChr  = chr;
        }

        void RestoreStateAndPos(Context ctx)
        {
            buffer.Pos = ctx.bPos;
            cNum  = ctx.cNum;
            state = ctx.state;
            chr   = ctx.cChr;
        }

        void RestorePos(Context ctx) { buffer.Pos = ctx.bPos; cNum = ctx.cNum; }
#endif // BACKUP

        // ============= End of the tokenizer code ================

#if STACK        
        internal void yy_clear_stack() { scStack.Clear(); }
        internal int yy_top_state() { return scStack.Peek(); }
        
        internal void yy_push_state(int state)
        {
            scStack.Push(currentScOrd);
            BEGIN(state);
        }
        
        internal void yy_pop_state()
        {
            // Protect against input errors that pop too far ...
            if (scStack.Count > 0) {
				int newSc = scStack.Pop();
				BEGIN(newSc);
            } // Otherwise leave stack unchanged.
        }
 #endif // STACK

        internal void ECHO() { Console.Out.Write(yytext); }
        
#region UserCodeSection

public void Analiziraj()
        {
            lineTot = 1;
            Adr_IDN = 0;
            Adr_KONS = 0;
            pointer = 0;
            ulazno_Polje.Dodaj_izvorno("");
            ulazno_Polje.Dodaj_redak(0);
            ulazno_Polje.Dodaj_uniformno("");
            Lists.IDENT_List.Clear();
            Lists.KONST_List.Clear();
            Lists.KROS_List.Clear();
            Tabl_unif_znak = new TUZ();
            Tabl_unif_znak.UNIFORM_Z_List.Clear();
            
            Lists.AddKrosList();

            int tok;
            this.SetSource(Glavni.mojaForma.editbox.Text, 0);
            do
                {
                    tok = this.yylex();
                } while (tok > (int)Tokens.EOF);
            Lists.Ispsi_KROS();
            Lists.Ispsi_IDEN();
            Lists.Ispsi_KONS();
            Tabl_unif_znak.Ispis();
            Parser mojParser = new Parser();
            mojParser.Parsiraj(); 
        }

#endregion
    } // end class Scanner
} // end namespace
